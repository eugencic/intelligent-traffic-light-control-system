// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.4
// source: traffic_regulation.proto

package __

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	TrafficRegulation_ReceiveDataForLogs_FullMethodName             = "/main.TrafficRegulation/ReceiveDataForLogs"
	TrafficRegulation_GetTodayControlLogs_FullMethodName            = "/main.TrafficRegulation/GetTodayControlLogs"
	TrafficRegulation_GetLastWeekControlLogs_FullMethodName         = "/main.TrafficRegulation/GetLastWeekControlLogs"
	TrafficRegulation_TrafficRegulationServiceStatus_FullMethodName = "/main.TrafficRegulation/TrafficRegulationServiceStatus"
)

// TrafficRegulationClient is the client API for TrafficRegulation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrafficRegulationClient interface {
	ReceiveDataForLogs(ctx context.Context, in *TrafficDataForLogs, opts ...grpc.CallOption) (*TrafficDataForLogsReceiveResponse, error)
	GetTodayControlLogs(ctx context.Context, in *IntersectionRequestForLogs, opts ...grpc.CallOption) (*TrafficRegulationResponse, error)
	GetLastWeekControlLogs(ctx context.Context, in *IntersectionRequestForLogs, opts ...grpc.CallOption) (*TrafficRegulationResponse, error)
	TrafficRegulationServiceStatus(ctx context.Context, in *TrafficRegulationServiceStatusRequest, opts ...grpc.CallOption) (*TrafficRegulationServiceStatusResponse, error)
}

type trafficRegulationClient struct {
	cc grpc.ClientConnInterface
}

func NewTrafficRegulationClient(cc grpc.ClientConnInterface) TrafficRegulationClient {
	return &trafficRegulationClient{cc}
}

func (c *trafficRegulationClient) ReceiveDataForLogs(ctx context.Context, in *TrafficDataForLogs, opts ...grpc.CallOption) (*TrafficDataForLogsReceiveResponse, error) {
	out := new(TrafficDataForLogsReceiveResponse)
	err := c.cc.Invoke(ctx, TrafficRegulation_ReceiveDataForLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficRegulationClient) GetTodayControlLogs(ctx context.Context, in *IntersectionRequestForLogs, opts ...grpc.CallOption) (*TrafficRegulationResponse, error) {
	out := new(TrafficRegulationResponse)
	err := c.cc.Invoke(ctx, TrafficRegulation_GetTodayControlLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficRegulationClient) GetLastWeekControlLogs(ctx context.Context, in *IntersectionRequestForLogs, opts ...grpc.CallOption) (*TrafficRegulationResponse, error) {
	out := new(TrafficRegulationResponse)
	err := c.cc.Invoke(ctx, TrafficRegulation_GetLastWeekControlLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trafficRegulationClient) TrafficRegulationServiceStatus(ctx context.Context, in *TrafficRegulationServiceStatusRequest, opts ...grpc.CallOption) (*TrafficRegulationServiceStatusResponse, error) {
	out := new(TrafficRegulationServiceStatusResponse)
	err := c.cc.Invoke(ctx, TrafficRegulation_TrafficRegulationServiceStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrafficRegulationServer is the server API for TrafficRegulation service.
// All implementations must embed UnimplementedTrafficRegulationServer
// for forward compatibility
type TrafficRegulationServer interface {
	ReceiveDataForLogs(context.Context, *TrafficDataForLogs) (*TrafficDataForLogsReceiveResponse, error)
	GetTodayControlLogs(context.Context, *IntersectionRequestForLogs) (*TrafficRegulationResponse, error)
	GetLastWeekControlLogs(context.Context, *IntersectionRequestForLogs) (*TrafficRegulationResponse, error)
	TrafficRegulationServiceStatus(context.Context, *TrafficRegulationServiceStatusRequest) (*TrafficRegulationServiceStatusResponse, error)
	mustEmbedUnimplementedTrafficRegulationServer()
}

// UnimplementedTrafficRegulationServer must be embedded to have forward compatible implementations.
type UnimplementedTrafficRegulationServer struct {
}

func (UnimplementedTrafficRegulationServer) ReceiveDataForLogs(context.Context, *TrafficDataForLogs) (*TrafficDataForLogsReceiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveDataForLogs not implemented")
}
func (UnimplementedTrafficRegulationServer) GetTodayControlLogs(context.Context, *IntersectionRequestForLogs) (*TrafficRegulationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTodayControlLogs not implemented")
}
func (UnimplementedTrafficRegulationServer) GetLastWeekControlLogs(context.Context, *IntersectionRequestForLogs) (*TrafficRegulationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastWeekControlLogs not implemented")
}
func (UnimplementedTrafficRegulationServer) TrafficRegulationServiceStatus(context.Context, *TrafficRegulationServiceStatusRequest) (*TrafficRegulationServiceStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficRegulationServiceStatus not implemented")
}
func (UnimplementedTrafficRegulationServer) mustEmbedUnimplementedTrafficRegulationServer() {}

// UnsafeTrafficRegulationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrafficRegulationServer will
// result in compilation errors.
type UnsafeTrafficRegulationServer interface {
	mustEmbedUnimplementedTrafficRegulationServer()
}

func RegisterTrafficRegulationServer(s grpc.ServiceRegistrar, srv TrafficRegulationServer) {
	s.RegisterService(&TrafficRegulation_ServiceDesc, srv)
}

func _TrafficRegulation_ReceiveDataForLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficDataForLogs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficRegulationServer).ReceiveDataForLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficRegulation_ReceiveDataForLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficRegulationServer).ReceiveDataForLogs(ctx, req.(*TrafficDataForLogs))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficRegulation_GetTodayControlLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntersectionRequestForLogs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficRegulationServer).GetTodayControlLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficRegulation_GetTodayControlLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficRegulationServer).GetTodayControlLogs(ctx, req.(*IntersectionRequestForLogs))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficRegulation_GetLastWeekControlLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntersectionRequestForLogs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficRegulationServer).GetLastWeekControlLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficRegulation_GetLastWeekControlLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficRegulationServer).GetLastWeekControlLogs(ctx, req.(*IntersectionRequestForLogs))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrafficRegulation_TrafficRegulationServiceStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficRegulationServiceStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrafficRegulationServer).TrafficRegulationServiceStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrafficRegulation_TrafficRegulationServiceStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrafficRegulationServer).TrafficRegulationServiceStatus(ctx, req.(*TrafficRegulationServiceStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrafficRegulation_ServiceDesc is the grpc.ServiceDesc for TrafficRegulation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrafficRegulation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.TrafficRegulation",
	HandlerType: (*TrafficRegulationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReceiveDataForLogs",
			Handler:    _TrafficRegulation_ReceiveDataForLogs_Handler,
		},
		{
			MethodName: "GetTodayControlLogs",
			Handler:    _TrafficRegulation_GetTodayControlLogs_Handler,
		},
		{
			MethodName: "GetLastWeekControlLogs",
			Handler:    _TrafficRegulation_GetLastWeekControlLogs_Handler,
		},
		{
			MethodName: "TrafficRegulationServiceStatus",
			Handler:    _TrafficRegulation_TrafficRegulationServiceStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "traffic_regulation.proto",
}
